# next-intl

项目使用[next-intl](https://next-intl.dev/docs/environments)进行国际化.

next-intl会从浏览器的请求头中获取语言信息(例如zh),并将url重定向到`/zh/xx`.这是国际通用的多语言url方案,也有利于seo.

# next-intl的配置

next-intl的配置是约定式的，从指定路径和名称的文件中获取导出，项目中参考文档进行如下配置:

## `@/../messages/xx.json`

语言包.每个语言使用一个json文件描述

## `@/i18n`

next-intl的核心配置

### `routing.ts`

路由信息，获取当前的locale、默认语言等

### `request.ts`

根据当前locale获取语言包、格式化函数等.

### `navigation.ts`

与路由相关的组件、hook和函数,用于在保持语言不变的情况下进行路由操作

<span style="color:red;font-weight:bolder;font-size:16px">注意：</span>在项目中 大部分情况都需要导入`@/i18n/navigation`而非`next/navigation`

### `type.ts`

自定义配置,为next-intl的翻译函数增加类型信息

## `@/proxy.ts`

重定向url到对应的语言(即,'/'->'/zh')

# 在页面中使用next-intl

在`app/[locale]`下实际使用next-intl `app/`具有功能性

## `app/`

### page

如果将项目打包为静态html 则中间件不可用 需要由此页面进行重定向

### not-found

如果请求没有被中间件转发 例如url是`/xxx.txt` 没有匹配到中间件 就需要展示这个not-found.

这个组件是无法被国际化的 用Next自带的404即可

### layout

不能返回`<html>` 它无法正确设置lang属性

## `app/[locale]`

这个路由下的所有组件都可以获取locale信息并进行翻译

### next-intl的导出

除了可以从`@/i18n/routing` `@/i18n/navigate`获取locale信息 `next-intl`还提供了一些通用的函数和类型

所有合法的语言值

```ts
import type { Locale } from 'next-intl'
```

判断一个语言是否合法

```ts
import { hasLocale } from 'next-intl'
import { routing } from '@/i18n/routing'

hasLocale(routing.locales, someLocale)
```

### 服务端

`next-intl/server`导出了一系列get函数 返回promise 在服务端进行翻译

```ts
import { getMessages, getTranslations, getLocale } from 'next-intl/server'

const locale = await getLocale()
const t = await getTranslations({ locale, namespace: 'metadata' })
const messages = await getMessages({ locale })
```

可以用于服务端组件 可以用在`generateMetadata`里 动态生成元数据

```ts
export async function generateMetadata(props: ParamsWithLocale): Promise<Metadata> {
  const { params } = props
  const { locale } = await params
  const t = await getTranslations({ locale, namespace: 'metadata' })

  return {
    title: t('title'),
  }
}
```

`ParamsWithLocale`是自定义的类型

```ts
type ParamsWithLocale<T = object> = { params: Promise<{ locale: AppConfig['Locale'] } & T> }
```

用于简化params和locale的获取 用在服务端组件的props里

### 客户端组件

客户端组件要想翻译 必须有服务端组件提供数据

```tsx
import { pick } from 'lodash-es'

const locale = await getLocale()
const messages = await getMessages({ locale })
// messages可以只传一部分
return (
  <NextIntlClientProvider locale={locale} messages={pick(messages, 'common')}>
    {children}
  <NextIntlClientProvider>
)
```

在`NextIntlClientProvider`内 客户端组件可以使用`next-intl`导出的一系列hook

```ts
import { useLocale, useMessages, useTranslations } from 'next-intl'
```

作用和服务端的函数相同 但是它们的取值是由`NextIntlClientProvider`的参数控制的

# 打包为静态html

除了next.config中`output`设置为`'export'`外 还需要做以下的设置

## SSG

```ts
import { routing } from '@/i18n/routing'

export function generateStaticParams() {
  return routing.locales.map((locale) => ({ locale }))
}
```

为每个语言生成html(或者挑选其中的几个)

将它放在任何需要的layout或者page即可.

如果打包为静态文件 则要必须要在`app/[locale]/layout`放置此函数

## get系列函数

服务端不能使用getLocale获取语言 而要使用ParamsWithLocale 从url里获取

另外 必须传入locale 不传的话会从header里获取

## `@/app/page`

如果将项目打包为静态html 则中间件不可用 需要由此页面进行重定向

## `@/i18n/routing`

localeDetection设置为false 否则会从header里获取语言

## `@/i18n/navigation`
