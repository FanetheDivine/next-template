# next-intl

项目使用[next-intl](https://next-intl.dev/docs/environments)进行国际化.

next-intl会从浏览器的请求头中获取语言信息(例如zh),并将url重定向到`/zh/xx`.这是国际通用的多语言url方案,也有利于seo.

# next-intl的配置

next-intl的配置是约定式的，从指定路径和名称的文件中获取导出，项目中参考文档进行如下配置:

## `@/../messages/xx.json`

语言包.每个语言使用一个json文件描述

## `@/i18n/`

next-intl的核心配置

### `routing.ts`

路由信息，获取当前的locale、默认语言等

localePrefix配置控制url里语言前缀(/zh/xxx)的形式:

- 'always' 总是携带语言前缀.推荐使用 这个也是默认值
- 'as-needed' 默认语言之外的使用前缀
- 'never' 总是不使用前缀 根据header判断语言

### `request.ts`

根据当前locale获取语言包、格式化函数等.

### `navigation.ts`

与路由相关的组件、hook和函数,用于在保持语言不变的情况下进行路由操作

<span style="color:red;font-weight:bolder;font-size:16px">注意：</span>在项目中 大部分情况都需要导入`@/i18n/navigation`而非`next/navigation`

### `type.ts`

自定义配置,为next-intl的翻译函数增加类型信息

## `@/proxy.ts`

重定向url到对应的语言(即,'/'->'/zh')

# 在页面中使用next-intl

在`app/[locale]`下实际使用next-intl `app/`具有功能性

## `app/`

### page

如果将项目打包为静态html 则中间件不可用 需要由此页面进行重定向

### not-found

如果请求没有被中间件转发 例如url是`/xxx.txt` 没有匹配到中间件 就需要展示这个not-found.

这个组件是无法被国际化的

### layout

不能返回`<html>` 它无法正确设置lang属性

## `app/[locale]`

这个路由下的所有组件都可以获取locale信息并进行翻译

### `app/[locale]/[...rest]/page`

`/locale/`路径下的not-found

### 通用函数

以下函数在客户端和服务端都可以使用

所有合法的语言值

```ts
import type { Locale } from 'next-intl'
```

判断一个语言是否合法

```ts
import { hasLocale } from 'next-intl'
import { routing } from '@/i18n/routing'

hasLocale(routing.locales, someLocale)
```

### 服务端

`next-intl/server`导出了一系列get函数 返回promise 在服务端进行翻译

```ts
import { getMessages, getTranslations, getLocale } from 'next-intl/server'

const locale = await getLocale()
const t = await getTranslations()
const messages = await getMessages({ locale })
```

可以用于服务端组件 也可以用在`generateMetadata`里 动态生成元数据

```ts
export async function generateMetadata(): Promise<Metadata> {
  const t = await getTranslations()
  return {
    title: t('title'),
  }
}
```

### 客户端组件

客户端组件要想翻译 必须有服务端组件提供数据

自动将服务端接受的locale和messages输入客户端

```html
<NextIntlClientProvider>{children}</NextIntlClientProvider>
```

messages可以只传一部分

```ts
import { pick } from 'lodash-es'

const locale = await getLocale()
const messages = await getMessages({ locale })
```

```html
<NextIntlClientProvider locale={locale} messages={pick(messages, 'common')}>
  {children}
<NextIntlClientProvider>
```

在`NextIntlClientProvider`包裹的范围内 客户端组件可以使用`next-intl`导出的一系列hook

```ts
import { useLocale, useMessages, useTranslations } from 'next-intl'
```

作用和服务端的函数相同 但是它们的取值是由`NextIntlClientProvider`的参数控制的

# 打包为静态html

`/[locale]/[...rest]/page`国际化的404页面将无法打包 必须删除 找不到页面将展示全局的404

`/[locale]/layout`必须从`params`里获取locale 然后调用`setRequestLocale`设置语言信息.这之后才能正常调用getXXX函数 否则这些函数会从请求头里获取语言信息
